[
  {
    "cveId": "<removed>",
    "data": "--- a/typd_mlc.c\n+++ b/typd_mlc.c\n@@ -627,6 +627,15 @@ GC_API GC_ATTR_MALLOC void * GC_CALL\n    return((void *) op);\n }\n \n+#include <limits.h>\n+#ifdef SIZE_MAX\n+# define GC_SIZE_MAX SIZE_MAX\n+#else\n+# define GC_SIZE_MAX (~(size_t)0)\n+#endif\n+\n+#define GC_SQRT_SIZE_MAX ((1U << (WORDSZ / 2)) - 1)\n+\n GC_API GC_ATTR_MALLOC void * GC_CALL GC_calloc_explicitly_typed(size_t n,\n                                                         size_t lb, GC_descr d)\n {",
    "fileName": "typd_mlc.c",
    "id": "<removed>",
    "patchId": "<removed>",
    "patchsetId": "<removed>"
  },
  {
    "cveId": "<removed>",
    "data": "--- a/typd_mlc.c\n+++ b/typd_mlc.c\n@@ -640,15 +649,18 @@ GC_API GC_ATTR_MALLOC void * GC_CALL GC_calloc_explicitly_typed(size_t n,\n     GC_ASSERT(GC_explicit_typing_initialized);\n     descr_type = GC_make_array_descriptor((word)n, (word)lb, d, &simple_descr,\n                                           &complex_descr, &leaf);\n+    if ((lb | n) > GC_SQRT_SIZE_MAX /* fast initial check */\n+        && lb > 0 && n > GC_SIZE_MAX / lb)\n+      return NULL; /* n*lb overflow */\n+    lb *= n;\n     switch(descr_type) {\n         case NO_MEM: return(0);\n-        case SIMPLE: return(GC_malloc_explicitly_typed(n*lb, simple_descr));\n+        case SIMPLE:\n+            return GC_malloc_explicitly_typed(lb, simple_descr);\n         case LEAF:\n-            lb *= n;\n             lb += sizeof(struct LeafDescriptor) + TYPD_EXTRA_BYTES;\n             break;\n         case COMPLEX:\n-            lb *= n;\n             lb += TYPD_EXTRA_BYTES;\n             break;\n     }",
    "fileName": "typd_mlc.c",
    "id": "<removed>",
    "patchId": "<removed>",
    "patchsetId": "<removed>"
  }
]